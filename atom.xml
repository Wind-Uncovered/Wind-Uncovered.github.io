<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wind-uncovered.github.io</id>
    <title>Belgrade&apos;s blog</title>
    <updated>2020-04-19T11:31:47.330Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wind-uncovered.github.io"/>
    <link rel="self" href="https://wind-uncovered.github.io/atom.xml"/>
    <subtitle>初创时期，会记录下多少东西呢？</subtitle>
    <logo>https://wind-uncovered.github.io/images/avatar.png</logo>
    <icon>https://wind-uncovered.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Belgrade&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[MITcs6001 lec4,ps4]]></title>
        <id>https://wind-uncovered.github.io/post/mitcs6001-lec4ps4/</id>
        <link href="https://wind-uncovered.github.io/post/mitcs6001-lec4ps4/">
        </link>
        <updated>2020-04-19T11:27:38.000Z</updated>
        <content type="html"><![CDATA[<center><h1><p>Lecture 4 : Handout</p></h1></center>
<h2><p style = "color:#fb8c00">Main Idea</p></h2>
<ul>
<li>
<p>Function</p>
<p>I consider the function as a bundle of code, as perfessor said, its character is about two usage: <code>Decomposition</code> and <code>Abstract</code></p>
<p>Accordind to <code>Decopmosition</code> , the construction of the programming emerged from the mass of code. It helps people easier to control the program.</p>
<p>And comes to <code>Abstract</code>, which is a term for black box, it seal the complexity of code, and make it more easy to reuse.</p>
</li>
<li>
<p>Scope</p>
<p><code>Scope</code> is a map. A map is constructed by the domain and range.</p>
<p>The domain of <code>Scope</code> is the name you used, so the range of <code>Scope</code> is the object in the memory.</p>
</li>
</ul>
<h2><p style = "color:#fb8c00">Problem Set #4
    </br> Pseudocode Solutions</p></h2>
<h3><p style = "color:#e65100">Introduction:</p></h3>
<p style = "color:#09a383">Encryption is the process of obscuring information to make it unreadable without special knowledge. For centuries, people have devised schemes to encrypt messages — some better than others — but the advent of the computer and the Internet revolutionized the field. These days, it's hard not to encounter some sort of encryption, whether you are buying something online or logging into Athena.</p>
<p style = "color:#09a383">
    A cipher is an algorithm for performing encryption (and the reverse, decryption). The original information is called plaintext. After it is encrypted, it is called ciphertext. The ciphertext message contains all the information of the plaintext message, but it's not in a format readable by a human or computer without the proper mechanism to decrypt it; it should resemble random gibberish to those not intended to read it.</p>
<p style = "color:#09a383">A cipher usually depends on a piece of auxiliary information, called a key. The key is incorporated into the encryption process; the same plaintext encrypted with two different keys should have two different ciphertexts. Without the key, it should be difficult to decrypt the resulting ciphertext into readable plaintext.</p>
<p style = "color:#09a383">
This assignment will deal with a well-known (though not very secure) encryption method called the Caesar cipher. In this problem set you will need to devise your own algorithms and will practice using recursion to solve a non-trivial problem.</p>
<h3><p style = "color:#e65100">Solution: </p></h3>
<p>在问题二中，我做出了一个排序字典的算法，但在用这个字典来决定最佳秘钥时，我意识到对字典排序是几乎没有意义的事情，因为字典不能通过索引取值。</p>
<p>除此之外，我还发现了一个很申必的事情，对一个列表使用set函数去重，它有时候会保持原有顺序，有时候不会，真是太申必了。尽管我重构了算法解决了这一毛病，但是没有记录下当时的代码和结果让人有点遗憾。真是太申必了。</p>
<pre><code class="language-python"># Problem 1 Encryption and Decryption


def build_coder(shift):
    &quot;&quot;&quot;
    Returns a dict that can apply a Caesar cipher to a letter.
    The cipher is defined by the shift value. Ignores non-letter characters
    like punctuation and numbers.
    &quot;&quot;&quot;

    shift = shift % 27
    asc_lst1 = &quot;abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz&quot;
    asc_lst2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
    lst = &quot; ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;
    dic = {}
    dic[&quot;!&quot;] = &quot;!&quot;
    dic[&quot;,&quot;] = &quot;,&quot;
    dic[&quot;.&quot;] = &quot;.&quot;
    dic['&quot;'] = '&quot;'
    dic[&quot;?&quot;] = &quot;?&quot;
    dic[&quot;:&quot;] = &quot;:&quot;

    for letter in lst:
        if letter in asc_lst1:
            order = asc_lst1.find(letter) + shift
            dic[letter] = asc_lst1[order]
        elif letter in asc_lst2:
            order = asc_lst2.find(letter) + shift
            dic[letter] = asc_lst2[order]
    
    return dic


def ceaser_cryption(shift, letters):
    coder = build_coder(shift)
    message = &quot;&quot;

    for letter in letters:
        if letter in coder.keys():
            message += coder[letter]
        else:
            message += letter
    
    return message
    

# *************************************
# The part of Caesar Cipher is finished.
# But the problem is still unfinished bucause you don't know the shift key.
# To solve this problem, you can statisc the number of the text used in text.
# This may be helpful to find the key
# *************************************


# Problem 2 Code-breaking


def count_and_sort(text, mode = 'automode'):
    &quot;return the most used letter&quot;
    
    text = text.lower()
    original_dic = {}
    
    for letter in text:
        if letter not in original_dic.keys():
            original_dic[letter] = 1
        else:
            original_dic[letter] += 1
    
    lst = list(original_dic.values())
    lst.sort(reverse = True)

    lst_new = []
    for i in lst:
        if i not in lst_new:
            lst_new.append(i)

    if mode == &quot;drivemode&quot;:
        dic = {}
        for i in lst_new:
            for key, val in original_dic.items():
                if i == val:
                    dic[key] = val
    
        return dic
    else:
        dic = {}
        for key, val in original_dic.items():
            if val == lst_new[0]:
                dic[key] = val
        return dic


def shift_creater(shift_letter_list):
    s = 'efghijklmnopqrstuvwxyz abc'
    key = []
    for i in shift_letter_list:
        key.append(s.find(i))

    return key


# *************************************
# Based on above results, you can now achieve a shift list
# Besides, you can switch to the &quot;drivemode&quot; to decide which
#   key you want finally which is based on 
#   the method called &quot;Exhaustive Enumeration&quot;
# *************************************


# Problem 3 Multi-level Encryption &amp; Decryption


def apply_shifts(text, shifts):
    
    encode_message = &quot;&quot;    
        
    _i = 0
    for shift in shifts:
        coder = build_coder(shift[1])
        i = 0
        while i &lt; shift[0]:
            encode_message += coder[text[_i]]
            i += 1
        
    return encode_message


def load_code():
    name = &quot;fable.txt&quot;
    with open(name) as text:
        code = text.read()
    
    return code

def load_words():
    name2 = &quot;words.txt&quot;
    with open(name2) as text:
        line = text.read()
        wordlist = line.split(&quot; &quot;)
    
    return wordlist


def switch_code(word, code, wordlist):
    length = len(word) + 1
    renew_code = code[length:]
    for i in range(27):
        using_code = ceaser_cryption(i, renew_code)
        code_list = using_code.split(&quot; &quot;)
        if code_list[0].lower() in wordlist:
            word = code_list[0]
            return word


def decrypt_fable(code, wordlist):
    if not code:
        return 0

    length = 0

    for i in range(27):
        using_code = ceaser_cryption(i, code)
        code_list = using_code.split(&quot; &quot;)
        if code_list[0].lower() in wordlist:
            word = code_list[0]
            if not switch_code(word, code, wordlist):
                continue
            else:
                print(word)
                length = len(word) + 1
                break
    
    code_new = code[length:]
    decrypt_fable(code_new, wordlist)


if __name__ == &quot;__main__&quot;:
    # code = load_code()
    # s = '&quot;,.'
    # for i in s:
    #     code.replace(i, &quot;&quot;)
    # wordlist = load_words()
    # decrypt_fable(code, wordlist)
    for i in range(27):
        print(&quot;oh a he appointed &quot; + ceaser_cryption(i, &quot;tvtlu&quot;))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MIT SC6001 (3)]]></title>
        <id>https://wind-uncovered.github.io/post/mit-sc6001-3/</id>
        <link href="https://wind-uncovered.github.io/post/mit-sc6001-3/">
        </link>
        <updated>2020-04-19T11:25:25.000Z</updated>
        <content type="html"><![CDATA[<center><h1><p>Lecture 3 : Problem Solving</p></h1></center>
<h2><p style = "color:#fb8c00">Main Course</p></h2>
<ul>
<li>Decrementing function
<ul>
<li>map set of program variables to an integer</li>
<li>starts with a non-negative value</li>
<li>when &lt;=0, loop terminates</li>
<li>decressed each iteration</li>
</ul>
</li>
<li>Exhaustive Enumeration(an important idea)</li>
<li>range(x, y) =[x, x+1, ..., y-1]</li>
<li>Approximation
<ul>
<li>Find an answer that is good enough</li>
</ul>
</li>
<li>Bisection search
<ul>
<li>cut search space in half each iteration</li>
</ul>
</li>
</ul>
<h2><p style = "color:#fb8c00">Problem Set #3
    </br> Wordgames</p></h2>
<h3><p style = "color:#e65100">Introduction:</p></h3>
<p style = "color:#09a383">In this problem set, you'll implement two versions of the 6.00 wordgame!
</p>
<p style = "color:#09a383">
Don't be intimidated by the length of this problem set. It's a lot of reading, but it is very doable.
</p>
<p style = "color:#09a383">
Let's begin by describing the 6.00 wordgame: This game is a lot like Scrabble or Text Twist, if you've played those. Letters are dealt to players, who then construct one or more words out of their letters. Each valid word receives a score, based on the length of the word and the letters in that word.
</p>
<p style = "color:#09a383">
The rules of the game are as follows:
</p>
<h4><p style = "color:#afb42b">Dealing</p></h4>
<ul>
<li>A player is dealt a hand of n letters chosen at random (assume n=7 for now).</li>
<li>The player arranges the hand into as many words as they want out of the letters, but using each letter at most once.</li>
<li>Some letters may remain unused (these won't be scored).</li>
</ul>
<h4><p style = "color:#afb42b">Scoring</p></h4>
<ul>
<li>
<p>The score for the hand is the sum of the score for the words times the length of the word.</p>
</li>
<li>
<p>The score for a word is the sum of the points for letters in the word, multiplied by the length of the word, plus 50 points if all n letters are used on the first go.</p>
</li>
<li>
<p>Letters are scored as in Scrabble; A is worth 1, B is worth 3, C is worth 3, D is<br>
worth 2, E is worth 1, and so on. We have defined the dictionary</p>
<p><code>SCRABBLE_LETTER_VALUES</code></p>
<p>that maps each lowercase letter to its Scrabble letter value.</p>
</li>
<li>
<p>For example, ‘weed’ would be worth 32 points ((4+1+1+2)<em>4=32), as long as the hand actually has 1 ‘w’, 2 ‘e’s, and 1 ‘d’</em></p>
</li>
<li>
<p>*As another example, if n=7 and you get ‘waybill’ on the first go, it would be worth 155 points ((4+1+4+3+1+1+1)*7=105, +50) for the bonus of using all<br>
seven letters).</p>
</li>
</ul>
<h3><p style = "color:#e65100">Problems</p></h3>
<p>This problem ser is divided by two parts, <code>Part A</code> and <code>Part B</code>.</p>
<p><code>Part A</code> includes problems from 1 to 5, while <code>Part B</code> includes that from 6-a to 6-c. Have a good time with the problems.</p>
<p style = "color:#09a383">IF YOU NEED THE PROBLEM SET, YOU CAN GO TO MIT OCW, AND SEARCH 6001.</p>
<p style = "color:#09a383">OR YOU CAN CONTACT ME BY EAMIL: abdeeglr@163.com</p>
<h2><p style = "color:#fb8c00">Solution</p></h2
<pre><code class="language-python"># 6.00 Problem Set 3A Solutions
#
# The 6.00 Word Game
# Finished by: ABdeeglr


import random
import string


VOWELS = 'aeiou'
CONSONANTS = 'bcdfghjklmnpqrstvwxyz'
WORDLIST_FILENAME = &quot;words.txt&quot;


Global_Const_letters_to_value = {
    'a': 1, 'b': 3, 'c': 3, 'd': 2, 'e': 1,
    'f': 4, 'g': 2, 'h': 4, 'i': 1, 'j': 8,
    'k': 5, 'l': 1, 'm': 3, 'n': 1, 'o': 1,
    'p': 3, 'q': 10, 'r': 1, 's': 1, 't': 1,
    'u': 1, 'v': 4, 'w': 4, 'x': 8, 'y': 4, 'z': 10
}


# ___________________________________
#     initialize settings
#     create a word list reposities
#     generate a random hand
# ____________________________________


def load_words():
    &quot;&quot;&quot;
    Returns a list of valid words. Words are strings of lowercase letters.
    
    Depending on the size of the word list, this function may
    take a while to finish.
    &quot;&quot;&quot;
    with open(WORDLIST_FILENAME) as inFile:
        wordlist = []
        while True:
            line = inFile.readline()
            if not line:
                break
            else:
                wordlist.append(line.strip().lower())
    return wordlist


def deal_hand(n):
    &quot;Generate a new hand&quot;

    num_vowel = int(n / 3)
    num_const = n - num_vowel
    hand = {}
    
    for _i in range(num_vowel):
        x = VOWELS[random.randrange(len(VOWELS))]
        if x not in hand:
            hand[x] = 1
        else:
            hand[x] += 1
    
    for _j in range(num_const):
        x = CONSONANTS[random.randrange(len(CONSONANTS))]
        if x not in hand:
            hand[x] = 1
        else:
            hand[x] += 1
    
    return hand


def initialize_settings():
    &quot;&quot;&quot;
    According this function to get the texts and a hand
    &quot;&quot;&quot;
    hand_size = random.randint(6,15)
    wordlist = load_words()
    hand = deal_hand(hand_size)

    return wordlist, hand
# ___________________________________
#     beginning of the main funcition
#     include:
#         get_word_score()
#         get_frequency_dict()
#         display_hand()
#         update_hand()
#         is_word_in_hand()
#         is_valid_word()
# ____________________________________


def get_word_score(word):
    # calculate the score of a word, but still not the ture score of a hand
    if not word:
        return 0
    else:
        usingword = word.lower()
        sum = 0
        for letter in usingword:
            sum += Global_Const_letters_to_value[letter]
        
        return sum * len(usingword)


def get_frequency_dict(word):
    &quot;Convert the word to a dict object&quot;

    dic = {}
    for letter in word:
        if letter not in dic:
            dic[letter] = 1
        else:
            dic[letter] += 1
    
    return dic


def display_hand(hand):
    &quot;display a hand in a user-friendly way&quot;
    for letter in hand.keys():
        for _i in range(hand[letter]):
            print(letter, end=&quot; &quot;)
    print()


def update_hand(word, hand):
    for letter in word:
        hand[letter] -= 1
        if hand[letter] == 0:
            del hand[letter]
    return hand


def is_word_in_hand(word, hand):
    for letter in word:
        if letter in hand.keys():
            pass
        else:
            return False
    return True

def is_valid_word(word, hand, word_list):
    if word in word_list:
        if is_word_in_hand(word, hand):
            word = get_frequency_dict(word)
            for key in word.keys():
                if word[key] &gt; hand[key]:
                    return False
            return True
        else:
            return False
    else:
        return False


# main game construction
def main():
    print(&quot;Welcome to my game! Welcome!&quot;)
    print(&quot;Now is loading the file...&quot;)
    wordlist, usinghand = initialize_settings()
    print(f&quot;{len(wordlist)} words loaded.&quot;)
    print(&quot;Game start!&quot;)
    print()
    print(&quot;__________________________&quot;)
    
    play_hand(usinghand, wordlist)
    while True:
        print(&quot;&quot;&quot;
              Do you want to play it again?
              enter 'n' to play a *new* hand.
              enter 'r' to play the last hand again.
              enter 'e' to quit the game
              &quot;&quot;&quot;)

        ans = input(&quot;&gt;&gt;&quot;)
        if ans == 'n':
            wordlist, usinghand = initialize_settings()
            play_hand(usinghand, wordlist)
        elif ans == 'r':
            play_hand(usinghand, wordlist)
        elif ans == 'e':
            break
        else:
            print(&quot;我放弃！自毁程序启动！&quot;)
            for i in range(51):
                print(f&quot;自毁程序启动中！{50 - i}&quot;)
    

def play_hand(hand, word_list):
    &quot;Allow the users to play the given hand, as follows:&quot;
    score = 0
    total = 0
    player_round = 1
    while True:
        print(&quot;Current hand:  &quot;, end=&quot;&quot;)
        display_hand(hand)
        answer = input('Enter word, or a &quot;.&quot; to indicate that you are finished:')
        print()
        if answer == &quot;.&quot;:
            print(f&quot;Total score: {total}&quot;)
            break
        elif is_valid_word(answer, hand, word_list):
            score = get_word_score(answer)
            if get_frequency_dict(answer) == hand and player_round == 1:
                score += 50
            total += score
            print(f&quot;{answer} earned {score} points. Total: {total} points&quot;)
            hand = update_hand(answer, hand)
            player_round += 1
        else:
            print(&quot;Invalid word, Please try agian.&quot;)
            player_round += 1
        

        if not hand:
            break

if __name__ == '__main__':
    main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CS学习笔记(2)]MIT6001  Lecture 2 : Handout]]></title>
        <id>https://wind-uncovered.github.io/post/cs-xue-xi-bi-ji-2mit6001-lecture-2-handou/</id>
        <link href="https://wind-uncovered.github.io/post/cs-xue-xi-bi-ji-2mit6001-lecture-2-handou/">
        </link>
        <updated>2020-04-07T09:06:12.000Z</updated>
        <content type="html"><![CDATA[<center><h1><p>Lecture 2 : Handout</p></h1></center>
<h2><p style = "color:#fb8c00">Main Course</p></h2>
<ul>
<li>
<p>IDLE- Integrated Deveiopment Environment</p>
<p>includes: text deitor &amp; shell &amp; integrated debugger</p>
<p>实际上我写代码完全不用IDLE，做简单测试用IDLE倒是极好的</p>
</li>
<li>
<p>Objects - has a type</p>
<p>scalar - indivisible</p>
<p>non-scalar</p>
</li>
<li>
<p>scalar</p>
<p><code>int</code> <code>float</code> <code>bool</code> <code>None</code> <code>str</code></p>
</li>
<li>
<p>Expression - sequence of operators &amp; operat...</p>
</li>
<li>
<p>Overloaded operators have a meaning that depends upon types of operands</p>
<p><code>+</code>也是一个重载运算符，这是一个很自然的忽略，因为人类的数学中不区分整数和浮点数。所以不必对“重载”这些属于感到害怕，都当成一个加号吧。</p>
</li>
<li>
<p>convert</p>
</li>
<li>
<p>program = script</p>
<p>老新手问题了。一个py文件就是一个脚本，但一个程序里面可能有很多个脚本共同组成。所以program=script，但在指向的内容上可能略有区分。</p>
</li>
<li>
<p>Variable is a way to name an object</p>
</li>
</ul>
<h2><p style = "color:#fb8c00">Problem Set #2 
    </br> Successive Approximation and a Wordgame</p></h2>
<h3><p style = "color:#e65100">Introduction:</p></h3>
<p style = "color:#09a383">Successive approximation is a problem-solving method where you try to guess the right answer to a problem and then check your guess. If the guess is good enough, you're done. Otherwise, you keep improving your guess in small increments and checking it, getting closer and closer to the right answer, until you determine that the guess is good enough. For the first 3 problems of this problem set, we will look at Newton's method, which uses successive approximation to find the roots of a function.
</p>
<p style = "color:#0277bd">逐次逼近是一种解决问题的方法，在此方法中，您尝试猜测问题的正确答案，然后检查您的猜测。 如果猜测足够好，那么您就完成了。 否则，您将不断以较小的增量改进猜测并进行检查，越来越接近正确的答案，直到您确定猜测足够好为止。 对于前三个问题
    在这个问题集上，我们将看一下牛顿的方法，该方法使用逐次逼近法来找到函数的根。</p>
<p style = "color:#09a383">
Secondly, we will have some fun with Python, and get some practice using strings and string operations. We would like you to implement the word game hangman as a 1-player game against the computer.
</p>
<p style = "color:#0277bd">其次，我们将对Python有所了解，并获得一些使用字符串和字符串操作的练习。 我们希望您将单词游戏hangman实施为针对计算机的1人游戏。</p>
<h3><p style = "color:#e65100">Polynomials</p></h3>
<figure data-type="image" tabindex="1"><img src="https://wind-uncovered.github.io/post-images/1586316338658.png" alt="" loading="lazy"></figure>
<h3><p style = "color:#e65100">Newton's Method</p></h3>
<figure data-type="image" tabindex="2"><img src="https://wind-uncovered.github.io/post-images/1586316354590.png" alt="" loading="lazy"></figure>
<h3><p style = "color:#e65100">Problem 1 : evaluate_poly function(多项式函数) </p></h3>
<p>Implement the evaluate_poly function. This function evaluates a polynomial function for the given x value. It takes in a tuple of numbers poly and a number x. By number, we mean that x and each element of poly is a float. evaluate_poly takes the polynomial represented by poly and computes its value at x. It returns this value as a float.</p>
<figure data-type="image" tabindex="3"><img src="https://wind-uncovered.github.io/post-images/1586316363158.png" alt="" loading="lazy"></figure>
<h3><p style = "color:#e65100">Problem 2 : compute_deriv function(求导函数)</p></h3>
<p>Implement the compute_deriv function. This function computes the derivative of a polynomial function. It takes in a tuple of numbers poly and returns the derivative, which is also a polynomial represented by a tuple.</p>
<figure data-type="image" tabindex="4"><img src="https://wind-uncovered.github.io/post-images/1586316368682.png" alt="" loading="lazy"></figure>
<h3><p style = "color:#e65100">Problem 3 : Implementing Newton's Method</p></h3>
<p>Implement the compute_root function. This function applies Newton's method of successive approximation as described above to find a root of the polynomial function. It takes in a tuple of numbers poly, an initial guess x_0, and an error bound epsilon. It returns a tuple. The first element is the root of the polynomial represented by poly; the second element is the number of<br>
iterations it took to get to that root.</p>
<p>The function starts at x_0. It then applies Newton's method. It ends when it finds a root x such that the absolute value of f(x) is less than epsilon, i.e. f(x) is close enough to zero. It returns the root it found as a float.</p>
<h3><p style = "color:#e65100">Problem 4 : Hangman</p></h3>
<h2><p style = "color:#fb8c00">Solution</p></h2>
<pre><code class="language-python"># 6.00 Problem Set 2
#
# newton method

def evaluate_poly(poly, x):
	&quot;&quot;&quot;
    Computes the value of a polynomial function at given value x. Returns that value.

    Example:
    &gt;&gt;&gt; poly = [0.0, 0.0, 5.0, 9.3, 7.0]    # f(x) = 5x^2 + 9.3x^3 + 7x^4 
    &gt;&gt;&gt; x = -13
    &gt;&gt;&gt; print evaluate_poly(poly, x)  # f(-13) = 5(-13)^2 + 9.3(-13)^3 + 7(-13)^4 
    180339.9

    poly: list of numbers, length &gt; 0
    x: number
    returns: float
    &quot;&quot;&quot;
	result = 0
	length = len(poly)

	for i in range(0, length):
		result += x**i*poly[i]

	return result



def compute_derivate(poly):
	&quot;&quot;&quot;
    Computes and returns the derivative of a polynomial function. If the
    derivative is 0, returns [0.0].

    Example:
    &gt;&gt;&gt; poly = [-13.39, 0.0, 17.5, 3.0, 1.0]    # - 13.39 + 17.5x^2 + 3x^3 + x^4
    &gt;&gt;&gt; print compute_deriv(poly)        # 35^x + 9x^2 + 4x^3
    [0.0, 35.0, 9.0, 4.0]

    poly: list of numbers, length &gt; 0
    returns: list of numbers
    &quot;&quot;&quot;
	length = len(poly)

	poly_new = [i*poly[i] for i in range(0,length)]
	poly_new.pop(0)

	return poly_new

# if __name__==&quot;__main__&quot;:
# 	poly = [1, 2, 3, 4]
# 	print(compute_derivate(poly))



def newton_root(poly, epsilon):
    &quot;&quot;&quot;
    
    Uses Newton's method to find and return a root of a polynomial function.
    Returns a list containing the root and the number of iterations required
    to get to the root.

    Example:
    &gt;&gt;&gt; poly = [-13.39, 0.0, 17.5, 3.0, 1.0]    # - 13.39 + 17.5x^2 + 3x^3 + x^4
    &gt;&gt;&gt; x_0 = 0.1
    &gt;&gt;&gt; epsilon = .0001
    &gt;&gt;&gt; print compute_root(poly, x_0, epsilon)
    [0.80679075379635201, 8]

    poly: list of numbers, length &gt; 1.
         Represents a polynomialfunction containing at least one real root.
         The derivative of this polynomial function at x_0 is not 0.
    x_0: float
    epsilon: float &gt; 0
    returns: list [float, int]
    &quot;&quot;&quot;
	root = poly[-1] / poly[0]
	counter = 1

	while abs(evaluate_poly(poly, root)) &gt;= epsilon:
		root = (root - evaluate_poly(poly, root) 
				/ evaluate_poly(compute_derivate(poly), root))
		counter += 1

	return [root,counter]

# if __name__==&quot;__main__&quot;:
# 	gx = [1, 2, 1]
# 	print(newton_root(gx, 0.001))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CS学习笔记(1)]MIT6001  intro to MIT_600]]></title>
        <id>https://wind-uncovered.github.io/post/cs-xue-xi-bi-ji-1mit600sc/</id>
        <link href="https://wind-uncovered.github.io/post/cs-xue-xi-bi-ji-1mit600sc/">
        </link>
        <updated>2020-04-06T04:40:07.000Z</updated>
        <content type="html"><![CDATA[<center><h1><p>Lecture 1: intro to MIT_600CS</p></h1></center>
<h2><p style = "color:#fb8c00">主要内容</p></h2>
<ul>
<li>
<p>Understand how to map problems into a computational<br>
framework</p>
</li>
<li>
<p>Declarative knowledge is composed of statements of fact</p>
</li>
</ul>
<blockquote>
<p>&quot;A good health care plan improves the quality of medical care while saving money&quot;<br>
&quot;y is the square root of x if and only if y*y = x&quot;</p>
</blockquote>
<ul>
<li>Imperative knowledge is about how to accomplish something. Think of it as recipe.</li>
</ul>
<blockquote>
<ol>
<li>Start with a guess, g</li>
<li>If g*g is close enough to x, then g is a good approximation of the square root of x</li>
<li>Otherwise, create a new guess by averaging g and x/g. i.e., g new = (g old + x/g old )/2</li>
<li>Using this new guess, go back to step 2</li>
</ol>
</blockquote>
<ul>
<li>Algorithm is how to perform a computation</li>
<li>fixed program computers &amp; stored program computers</li>
<li>冯诺依曼结构，视数据和程序为同一种事物</li>
<li>语言的构成:语法，静态语义，唯一语义</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://wind-uncovered.github.io/post-images/1586148100948.png" alt="" loading="lazy"></figure>
<ul>
<li>编译器和解释器的区别</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://wind-uncovered.github.io/post-images/1586148108927.png" alt="" loading="lazy"></figure>
<hr>
<h2><p style = "color:#fb8c00">Problem set</p></h2>
<h3><p style = "color:#e65100">Introduction:</p></h3>
<p style = "color:#09a383">This problem set will introduce you to using control flow in Python and formulating a computational solution to a problem. You will design and write three simple Python programs, test them, and hand them in. Be sure to read this problem set thoroughly.
</p>
<p style = "color:#0277bd">该问题集将向您介绍在Python中使用控制流并制定问题的计算解决方案。
    您将设计并编写三个简单的Python程序，对其进行测试并上交。请务必仔细阅读此问题集。</p>
<h3><p style = "color:#e65100">Paying Off Credit Card Debt:</p></h3>
<p style = "color:#09a383">Each month, a credit card statement will come with the option for you to pay a minimum amount of your charge, usually 2% of the balance due. However, the credit card company earns money by charging interest on the balance that you don’t pay. So even if you pay credit card payments on time, interest is still accruing on the outstanding balance.</p>
<p style = "color:#09a383">Say you’ve made a $5,000 purchase on a credit card with 18% annual interest rate and 2% minimum monthly payment rate. After a year, how much is the remaining balance? Use the following equations.</p>
<p><img src="https://wind-uncovered.github.io/post-images/1586148122351.png" alt="" loading="lazy"><br>
<img src="https://wind-uncovered.github.io/post-images/1586148128239.png" alt="" loading="lazy"></p>
<h3><p style = "color:#e65100">Problem 1: Paying the Minimum</p></h3>
<blockquote>
<p>Write a program to calculate the credit card balance after one year if a person only pays the minimum monthly payment required by the credit card company each month.</p>
</blockquote>
<blockquote>
<p>Use input() to ask for the following three floating point numbers:</p>
<ol>
<li>the outstanding balance on the credit card</li>
<li>annual interest rate</li>
<li>minimum monthly payment rate</li>
</ol>
</blockquote>
<blockquote>
<p>For each month, print the minimum monthly payment, remaining balance, principle paid in the format shown in the test cases below. All numbers should be rounded to the nearest penny.</p>
<p>Finally, print the result, which should include the total amount paid that year and the remaining balance.</p>
</blockquote>
<h3><p style = "color:#e65100">Problem 2 : Paying Debt Off In a Year</p></h3>
<blockquote>
<p>Now write a program that calculates the minimum fixed monthly payment needed in order pay off a credit card balance within 12 months. We will not be dealing with a minimum monthly payment rate.</p>
</blockquote>
<blockquote>
<p>Take as input() the following floating point numbers:</p>
<ol>
<li>the outstanding balance on the credit card</li>
<li>annual interest rate as a decimal</li>
</ol>
</blockquote>
<blockquote>
<p>Print out the fixed minimum monthly payment, number of months (at most 12 and possibly less than 12) it takes to pay off the debt, and the balance (likely to be a negative number).</p>
<p>Assume that the interest is compounded monthly according to the balance at the start of the month (before the payment for that month is made). The monthly payment must be a multiple of $10 and is the same for all months. Notice that it is possible for the balance to become negative using this payment scheme. In short:</p>
</blockquote>
<blockquote>
<p><em>Monthly interest rate</em> = Annual interest rate / 12.0</p>
<p><em>Updated balance each month</em> = Previous balance * (1 + Monthly interest rate) – Minimum monthly payment</p>
</blockquote>
<blockquote>
<p>Hints</p>
<p>Start at $10 payments per month and calculate whether the balance will be paid off (taking into account the interest accrued each month). If $10 monthly payments are insufficient to pay off the debt within a year, increase the monthly payment by $10 and repeat.</p>
</blockquote>
<hr>
<h2><p style = "color:#fb8c00">Solution</p></h2>
<pre><code class="language-python"># 6.00 PS1-A Solution
# Determines remaining credit card balance after a year of making the minimum payment each month

balance = float(input(&quot;Enter the outstanding balance on your credit card: &quot;))
initialBalance = balance
annualInterestRate = float(input(&quot;Enter the annual credit card interest rate as a decimal: &quot;))
minMonthlyPaymentRate = float(input(&quot;Enter the minimum monthly payment rate as a decimal: &quot;))
payinglengthintime = float(input(&quot;Enter how many years you will pay the credit card: &quot;))

# how many months you will pay the credit card
payinglengthintime = payinglengthintime * 12
print(&quot;You will have a payment in next __%d__ months.&quot;%(payinglengthintime))

# Monthly Interest Rate
monthlyInterestRate = annualInterestRate/12
print(&quot;The monthly interest rate is %d&quot; %(monthlyInterestRate))

# Initialize state variables
numMonths = 1
totalAmtPaid = 0

while numMonths &lt;= payinglengthintime:

	print(&quot;month: &quot;, numMonths)
	minPayment = minMonthlyPaymentRate * balance
	
	totalAmtPaid += minPayment
	print(&quot;You need to pay %d yuan.&quot;%(minPayment))
	
	interestPaid = monthlyInterestRate * balance
	principalPaid = minPayment - interestPaid
	
	balance = balance - principalPaid
	print(&quot;The remaining balance is %d yuan at all.&quot; %(balance))
	print(&quot;_________________________________&quot;)
	
	numMonths += 1
	
print(&quot;After %d years, the remaining balance is %d yuan.&quot;%(payinglengthintime / 12, balance))
print(&quot;Total amount paid:&quot;,totalAmtPaid)
print(&quot;The real interest is %f&quot;%(totalAmtPaid /payinglengthintime * 12 / initialBalance))
</code></pre>
<h4 id="ps1-a-test">PS1-A Test</h4>
<blockquote>
<p>Enter the outstanding balance on your credit card: 3000<br>
Enter the annual credit card interest rate as a decimal: 0.13<br>
Enter the minimum monthly payment rate as a decimal: 0.1<br>
Enter how many years you will pay the credit card: 1<br>
You will have a payment in next <strong>12</strong> months.<br>
The monthly interest rate is 0<br>
month:  1<br>
You need to pay 300 yuan.<br>
The remaining balance is 2732 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  2<br>
You need to pay 273 yuan.<br>
The remaining balance is 2488 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  3<br>
You need to pay 248 yuan.<br>
The remaining balance is 2266 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  4<br>
You need to pay 226 yuan.<br>
The remaining balance is 2064 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  5<br>
You need to pay 206 yuan.<br>
The remaining balance is 1880 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  6<br>
You need to pay 188 yuan.<br>
The remaining balance is 1712 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  7<br>
You need to pay 171 yuan.<br>
The remaining balance is 1560 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  8<br>
You need to pay 156 yuan.<br>
The remaining balance is 1421 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  9<br>
You need to pay 142 yuan.<br>
The remaining balance is 1294 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  10<br>
You need to pay 129 yuan.<br>
The remaining balance is 1178 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  11<br>
You need to pay 117 yuan.<br>
The remaining balance is 1073 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>month:  12<br>
You need to pay 107 yuan.<br>
The remaining balance is 978 yuan at all.</p>
</blockquote>
<hr>
<blockquote>
<p>After 1 years, the remaining balance is 978 yuan.<br>
Total amount paid: 2267.5388066194178<br>
The real interest is 0.755846</p>
</blockquote>
<h4 id="总结">总结：</h4>
<p>分期付款真的是一个挺可怕的割韭菜工具，简直一本万利，要不是具有社会功能，说不定得写进刑法里。</p>
<p>如果将每月必须还的金额继续调低，是很有可能一直还不清的。</p>
<p>这个脚本还有一些小地方没有修饰，但无关紧要了。</p>
<hr>
<pre><code class="language-python"># 6.00 PS1-B Solution
# Determines fixed minimum monthly payment needed to finish paying off credit card debt in 1 year

# Retrieve input
initialBalance = float(raw_input(&quot;Enter the outstanding balance on your credit card: &quot;))
interestRate = float(raw_input(&quot;Enter the annual credit card interest rate as a decimal: &quot;))

# Initialize state variables
monthlyPayment = 0
monthlyInterestRate = interestRate/12
balance = initialBalance

# Test increasing amounts of monthlyPayment in increments of $100
# until it can be paid off in a year
while balance &gt; 0:

    monthlyPayment += 10
    balance = initialBalance
    numMonths = 0
    
    # Simulate passage of time until outstanding balance is paid off
    # Each iteration represents 1 month
    while numMonths &lt; 12 and balance &gt; 0:
        
        # Count this as a new month     
        numMonths += 1

        # Interest for the month
        interest = monthlyInterestRate * balance
        
        # Subtract monthly payment from outstanding balance
        balance -= monthlyPayment

        # Add interest
        balance += interest

# Round final balance to 2 decimal places
balance = round(balance,2)

print &quot;RESULT&quot;
print &quot;Monthly payment to pay off debt in 1 year:&quot;, monthlyPayment
print &quot;Number of months needed:&quot;, numMonths
print &quot;Balance:&quot;,balance
</code></pre>
<p>这里我直接照搬了答案，因为这个题目的主要想法就是教授寻找根号5时的做法。具体的实现细节通过while循环来解决（虽然用函数可以进一步简化结构，但这个时候还没有教函数）。这个算法的核心是固定步长的迭代，然后控制好参数，使其在达到制定目标时结束循环，并返回值。</p>
<p>由于时间问题，ps1-C我就不做了。</p>
<p>本期笔记到此结束。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[转载] 编程入门指南]]></title>
        <id>https://wind-uncovered.github.io/post/zhuan-zai-bian-cheng-ru-men-zhi-nan/</id>
        <link href="https://wind-uncovered.github.io/post/zhuan-zai-bian-cheng-ru-men-zhi-nan/">
        </link>
        <updated>2020-04-03T16:34:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>作者：Badger4us<br>
链接：https://zhuanlan.zhihu.com/p/19959253<br>
来源：知乎<br>
著作权归作者所有，转载请联系作者获得授权。</p>
<p>作者：@萧井陌, @Badger</p>
<h2 id="自由转载-非商用-非衍生-保持署名-creative-commons-by-nc-nd-30cocode一个让大家学习-成长-相聚并获得乐趣的技术社区答疑邮箱-xiaoguaoutlookcom-萧井陌编程入门指南学习群177169777">自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0<br>
CoCode：一个让大家学习、成长、相聚并获得乐趣的技术社区<br>
答疑邮箱： xiao.gua@outlook.com （@萧井陌<br>
编程入门指南学习群：177169777</h2>
<p>2016年07月07日 v1.5 更新</p>
<p>2015年06月07日 v1.4 更新</p>
<p>2015年04月16日 v1.3 更新</p>
<p>2015年03月17日 v1.2 更新</p>
<p>2015年03月03日 v1.1 更新</p>
<p>2015年02月18日 v1.0 更新</p>
<hr>
<p>文章结构：</p>
<p>• 前言<br>
• 心态调整<br>
◦ 确定目标<br>
◦ 不要浮躁<br>
◦ 培养兴趣<br>
• 开始学习<br>
◦ 令人警醒的故事<br>
◦ 警醒后的反思<br>
◦ 启蒙<br>
◦ 入门<br>
▪ 计算机系统基础<br>
▪ 数据结构与算法基础<br>
▪ 编程语言基础<br>
▪ 其他<br>
◦ 小结<br>
• 后记</p>
<h2 id="附录-萧井陌-的编程类回答汇总">• 附录<br>
◦ @萧井陌 的编程类回答汇总<br>
◦ ...</h2>
<p>前言</p>
<p>如今编程成为了一个越来越重要的「技能」：作为设计师，懂一些编程可能会帮你更好地理解自己的工作内容；作为创业者，技术创始人的身份则会让你的很多工作显得更容易。而作为刚想入门的新手，面对眼前海量的信息，或许根本不知道从哪里开始；入门轻松度过初级材料的学习后，发现学习越来越困难，陡峭的学习曲线又让你望而却步；你知道如何在页面上打印输出一些文本行，但是你不知道何时该进行一个真正的有用的项目；你不清楚自己还有哪些不知道的东西，你甚至搞不清下一步该学什么。</p>
<p>这篇文章的内容对此不仅会有一些方向性的建议，还会包含一个基础核心向的编程入门导引。当然，Step by Step 的路线是不现实的，并且每个人都会有自己的特点，所以给出的这个编程入门导引更多的是为了引发读者的思考，最终帮助你形成适用于自己的学习路线。</p>
<p>但要注意：这篇文章是写给那些真心想学编程的人看的——那些憋着一股狠劲儿，一定要做出个什么真东西，不学好不罢休的人；而不是那些「听说编程好玩」的人，在我看来，这种人永远都入不了编程的门，更别提做出个像样的东西来了。</p>
<hr>
<p>「Disclaimer」： 虽然整篇文章的基调都是所谓的「Strong Opinions, Weakly Held」，但读者还是应该像怀疑身边所有东西那样 怀疑我们所写内容的准确性。若有任何相关疑问欢迎在知乎或技术社区 CoCode 公开讨论。</p>
<p>心态调整</p>
<p>确定目标</p>
<p>在你学习编程之前思考一下你的目标，当你有最终目标时道路会更加的清晰。那么，你想要写什么？网站？游戏？ iOS 或者 Android 应用？或是你是想自动化完成一些乏味的任务让你有更多的时间看窗外的风景？也许你只是想更具有就业竞争力找个好工作。所有的这些都是有价值的目标，这些目标都是你编程学习推动力的一部分，没有推动力的人，是无法在略显枯燥的漫长学习之旅中走远的。</p>
<p>这段视频也许能给你启发：What Most Schools Don't Teach</p>
<p>不要浮躁</p>
<p>Bad programming is easy. Even Dummies can learn it in 21 days. Good programming requires thought, but everyone can do it and everyone can experience the extreme satisfaction that comes with it.</p>
<p>不管是在线下还是线上的书店，满目都是《21天学通 X》这种速成书目，它们都承诺在很短一段时间内就让你能够学会相关技术。Matthias Felleisen 在他的著作 How to Design Programs 一书中明确指出了这种「速成」的趋势并予以了以上的讽刺。</p>
<p>所谓的「捷径」或者说「银弹」是不存在的，智者说过，精通某个东西需要10年或10000个小时，也就是汉语中的「十年磨一剑」，所以不用着急，功不唐捐。</p>
<p>培养兴趣</p>
<p>Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program.</p>
<p>– Linus Torvalds</p>
<p>沉醉于编程，编程更是为了兴趣。兴趣是推动力的不竭源泉，保持这种充满兴趣的感觉，以便于你能将其投入到你的10年/10000小时的编程时间中。编程很有趣，那是探索的喜悦。那是创造的喜悦。看到自己亲手完成的作品显示在屏幕上很有趣。有人为你的代码而惊叹很有趣。有人在公共场合称赞你的产品、邻居使用你的产品、以及在媒体上讨论你的产品很有趣。编程应该十分有趣，若并非如此，就找出导致编程无趣的问题，然后解决之。</p>
<p>开始学习</p>
<p>令人警醒的故事</p>
<p>刚上初中时我便开始了编程学习，很不幸，我读完了好几本当时普遍存在的诸如《21天精通C++》这类的垃圾书，当时读完也无大碍，甚至还能写点小程序。但是软件出故障了我不知道为什么，稍显庞大的编程问题无从下手，碰到现有的库做不到的事也只能两手一摊。虽然我每天不停地编码，但我发现自己的编程能力却是提高的如此缓慢，对于「迭代」与「递归」的概念只有极其有限的了解，可以说只是把计算机当成了计算器来使用。</p>
<p>进入大学后，我主修了物理学，最初的一段时间里我一直在记忆背诵那些物理公式，却不理解她们是如何得出的，她们之间有什么联系，亦或是她们的意义。我不停地学习如何计算解答一些常见的物理问题，却对在这些 How 背后的 Why 一无所知。</p>
<p>而在我尝试做一些基于物理行为的电脑游戏时我再次遇到了之前的的困难：面对新问题时无从下手，面对新问题时的恐惧不断累积滋生，我开始主动逃避，不去真正地理解，而是幻想能通过Google搜索复制粘贴代码解决问题。幸运的是，大二时的一堂课完全改变了我的学习方法。那是第一次我有了「开天眼」的感觉，我痛苦地意识到，我对一些学科只有少的可怜的真正的理解，包括我主修的物理与辅修的计算机科学。</p>
<p>关于那堂课：那时我们刚刚学习完电学和狭义相对论的内容，教授在黑板上写下了这两个主题，并画了一根线将他们连了起来。「假设我们有一个电子沿导线以相对论级别的速度移动…」，一开始教授只是写下了那些我们所熟悉的电学与狭义相对论的常见公式，但在数个黑板的代数推导后，磁场的公式神奇的出现了。虽然几年前我早已知道这个公式，但那时我根本不知道这些现象间的有着这样潜在的联系。磁与电之间的差别只是「观察角度」的问题，我猛然醒悟，此后我不再仅仅追求怎么做 (How)，我开始问为什么 (why)，开始回过头来，拾起那些最基础的部分，学习那些我之前我本该好好学的知识。这个回头的过程是痛苦的，希望你们能就此警醒，永远不要做这种傻事。</p>
<p>警醒后的反思</p>
<p>这幅图取自 Douglas Hofstadter 的著作 Gödel, Escher, Bach。图中的每一个字母都由其他更小的字母组成。在最高层级，我们看的是 &quot;MU&quot;，M 这个字母由三个 HOLISM （整全观）构成，U则是由一个 REDUCTIONISM （还原论）构成，前者的每一个字母都包含后者的后者整个词，反之亦然。而在最低层级，你会发现最小的字母又是由重复的 &quot;MU&quot; 组成的。</p>
<p>每一层次的抽象都蕴含着信息，如果你只是幼稚地单一运用整体论在最高层级观察，或运用还原论观察最低层级，你所得到的只有 &quot;MU&quot; （在一些地区的方言中 mu 意味着什么都没有）。问题来了，怎样才能尽可能多的获取每个层级的信息？或者换句话说，该怎样学习复杂领域（诸如编程）包含的众多知识？</p>
<p>教育与学习过程中普遍存在一个关键问题：初学者们的目标经常过于倾向整全观而忽略了基础，举个常见的例子，学生们非常想做一个机器人，却对背后的</p>
<p>理解物理模型 → 理解电子工程基础 → 理解伺服系统与传感器 → 让机器人动起来</p>
<p>这一过程完全提不起兴趣。</p>
<p>在这里对于初学者有两个大坑：</p>
<p>1 如果初学者们只与预先构建好的「发动机和组件」接触（没有理解和思考它们构造的原理），这会严重限制他们在将来构建这些东西的能力，并且在诊断解决问题时无从下手。<br>
2 第二个坑没有第一个那么明显：幼稚的「整体论」方法有些时候会显得很有效，这有一定的隐蔽性与误导性，但是一两年过后（也许没那么长），当你在学习路上走远时，再想回过头来「补足基础」会有巨大的心理障碍，你得抛弃之前自己狭隘的观念，耐心地缓步前进，这比你初学时学习基础知识困难得多。<br>
但也不能矫枉过正，陷入还原论的大坑，初学时便一心试图做宏大的理论，这样不仅有一切流于理论的危险，枯燥和乏味还会让你失去推动力。这种情况经常发生在计算机科班生身上。</p>
<p>为了更好理解，可以将学习编程类比为学习厨艺：你为了烧得一手好菜买了一些关于菜谱的书，如果你只是想为家人做菜，这会是一个不错的主意，你重复菜谱上的步骤也能做出不赖的菜肴，但是如果你有更大的野心，真的想在朋友面前露一手，做一些独一无二的美味佳肴，甚至成为「大厨」，你必须理解这些菜谱背后大师的想法，理解其中的理论，而不仅仅是一味地实践。但是如果你每天唯一的工作就是阅读那些厚重的理论书籍，因为缺乏实践，你只会成为一个糟糕的厨子，甚至永远成为不了厨子，因为看了几天书后你就因为枯燥放弃了厨艺的学习。</p>
<p>总之，编程是连接理论与实践的纽带，是计算机科学与计算机应用技术相交融的领域。正确的编程学习方法应该是：通过自顶而下的探索与项目实践，获得编程直觉与推动力；从自底向上的打基础过程中，获得最重要的通用方法并巩固编程思想的理解。</p>
<p>作为初学者，应以后者为主，前者为辅。</p>
<p>启蒙</p>
<p>「学编程应该学哪门语言？」这经常是初学者问的第一个问题，但这是一个错误的问题，你最先考虑的问题应该是「哪些东西构成了编程学习的基础」？</p>
<p>编程知识的金字塔底部有三个关键的部分：</p>
<p>• 算法思想：例如怎样找出一组数中最大的那个数？首先你得有一个 maxSoFar 变量，之后对于每个数…<br>
• 语法：我怎样用某种编程语言表达这些算法，让计算机能够理解。<br>
• 系统基础：为什么 while(1) 时线程永远无法结束？为什么 int *foo() { int x = 0; return &amp;x; } 是不可行的？<br>
启蒙阶段的初学者若选择C语言作为第一门语言会很困难并且枯燥，这是因为他们被迫要同时学习这三个部分，在能做出东西前要花费很多时间。</p>
<p>因此，为了尽量最小化「语法」与「系统基础」这两部分，建议使用 Python 作为学习的第一门语言，虽然 Python 对初学者很友好，但这并不意味着它只是一个「玩具」，在大型项目中你也能见到它强大而灵活的身影。熟悉 Python 后，学习 C 语言是便是一个不错的选择了：学习 C 语言会帮助你以靠近底层的视角思考问题，并且在后期帮助你理解操作系统层级的一些原理。</p>
<p>下面给出了一个可供参考的启蒙阶段导引，完成后你会在头脑中构建起一个整体框架，帮助你进行自顶向下的探索。下面的材料没有先后顺序，如果卡壳的话可以考虑换另一份材料。</p>
<p>• 完成 MIT 6.00.1x （麻省理工：计算机科学和 Python 编程导论）。虽然该课程的教学语言为 Python，但作为一门优秀的导论课，它强调学习计算机科学领域里的重要概念和范式，而不仅仅是教你特定的语言。如果你不是科班生，这能让你在自学时开阔眼界；课程内容：计算概念，Python 编程语言，一些简单的数据结构与算法，测试与调试。<br>
• 完成 Harvard CS50x （哈佛大学：计算机科学）。同样是导论课，但这门课与MIT的导论课互补。教学语言涉及 C, PHP, JavaScript + SQL, HTML + CSS，内容的广度与深度十分合理，还能够了解到最新的一些科技成果，可以很好激发学习计算机的兴趣。支线任务：阅读《编码》<br>
• 完成 Python 教程。</p>
<p>入门</p>
<p>结束启蒙阶段后，初学者积累了一定的代码量，对编程也有了一定的了解。这时你可能想去学一门具体的技术，诸如 Web 开发， Android 开发，iOS 开发什么的，你可以去尝试做一些尽可能简单的东西，给自己一些正反馈，补充自己的推动力。但记住别深入，这些技术有无数的细节，将来会有时间去学习；同样的，这时候也别过于深入特定的框架和语言，现在是学习计算机科学通用基础知识的时候，不要试图去抄近路直接学你现在想学的东西，这是注定会失败的。</p>
<p>那么入门阶段具体该做些什么呢？这时候你需要做的是反思自己曾经写过的程序，去思考程序为什么 (Why) 要这样设计？，思考怎样 (How) 写出更好的程序？试图去探寻理解编程的本质：利用计算机解决问题。</p>
<p>设想 ：</p>
<p>X = 用于思考解决方案的时间，即「解决问题」 部分</p>
<p>Y = 用于实现代码的时间，即「利用计算机」部分」</p>
<p>编程能力 = F(X, Y) （X&gt;Y）</p>
<p>要想提高编程能力，就得优化 X，Y 与函数 F(X, Y)，很少有书的内容能同时着重集中在这三点上，但有一本书做到了——Structure and Interpretation of Computer Programs (SICP)《计算机程序的构造和解释》，它为你指明了这三个变量的方向。在阅读 SICP 之前，你也许能通过调用几个函数解决一个简单问题。但阅读完 SICP 之后，你会学会如何将问题抽象并且分解，从而处理更复杂更庞大的问题，这是编程能力巨大的飞跃，这会在本质上改变你思考问题以及用代码解决问题的方式。此外，SICP 的教学语言为 Scheme，可以让你初步了解函数式编程。更重要的是，他的语法十分简单，你可以很快学会它，从而把更多的时间用于学习书中的编程思想以及复杂问题的解决之道上。</p>
<p>Peter Norvig 曾经写过一篇非常精彩的 SICP 书评，其中有这样一段：</p>
<p>To use an analogy, if SICP were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate SICP are the ones who just want to know how to drive their car on the highway, just like everyone else.</p>
<p>如果你是文中的前者，阅读SICP将成为你衔接启蒙与入门阶段的关键点</p>
<p>虽然SICP是一本「入门书」，但对于初学者还是有一定的难度，以下是一些十分有用的辅助资源：</p>
<p>• Udacity CS212 Design of Computer Program：由上文提到的Google 研究主管 Peter Norvig 主讲，教学语言为 Python，内容有一定难度。<br>
• How to Design Programs, Second Edition：HtDP 的起点比SICP低，书中的内容循循善诱，对初学者很友好，如果觉得完成SICP过于困难，可以考虑先读一读 HtDP。<br>
• UC Berkeley SICP 授课视频以及 SICP 的两位作者给 Hewlett-Packard 公司员工培训时的录像（中文化项目）<br>
• Composing Programs：一个继承了SICP思想但使用Python作为教学语言的编程导论（其中包含了一些小项目）<br>
• SICP 解题集：对于书后的习题，作为初学者应尽力并量力完成。<br>
完成了这部分学习后，你会逐步建立起一个自己的程序设计模型，你的脑子里不再是一团乱麻，你会意识到记住库和语法并不会教你如何解决编程问题，接下来要学些什么，在你心里也会明朗了很多。这时候才是真正开始进行项目实践，补充推动力的好时机。关于项目实践：对于入门阶段的初学者，参与开源项目还为时过早，这时候应该开始一些简单的项目，诸如搭建一个网站并维护它，或是编写一个小游戏再不断进行扩展，如果你自己的想法不明确，推荐你关注 炼瓜研究所 ，或者从 Mega Project List 中选取自己喜欢的项目。</p>
<p>如果你觉得 SICP 就是搞不定，也不要强迫自己，先跳过，继续走常规路线：开始读 The Elements of Computing Systems 吧，它会教会你从最基本的 Nand 门开始构建计算机，直到俄罗斯方块在你的计算机上顺利运行。 具体内容不多说了，这本书会贯穿你的整个编程入门阶段，你入门阶段的目标就是坚持完成这本书的所有项目（包括一个最简的编译器与操作系统）。</p>
<p>为了完全搞定这本书，为了继续打好根基。为了将来的厚积薄发，在下面这几个方面你还要做足功课（注意：下面的内容没有绝对意义上的先后顺序）：</p>
<p>计算机系统基础</p>
<p>有了之前程序设计的基础后，想更加深入地把握计算机科学的脉络，不妨看看这本书：Computer Systems: A Programmer's Perspective, 3/E《深入理解计算机系统》。这里点名批评这本书的中译名，其实根本谈不上什么深入啦，这本书只是 CMU 的「计算机系统导论」的教材而已。CMU的计算机科学专业相对较偏软件，该书就是从一个程序员的视角观察计算机系统，以「程序在计算机中如何执行」为主线，全面阐述计算机系统内部实现的诸多细节。</p>
<p>如果你看书觉得有些枯燥的话，可以跟一门 Coursera 上的 MOOC: The Hardware/Software Interface，这门课的内容是 CSAPP 的一个子集，但是最经典的实验部分都移植过来了。同时，可以看看 The C Programming Language，回顾一下C语言的知识。</p>
<p>完成这本书后，你会具备坚实的系统基础，也具有了学习操作系统，编译器，计算机网络等内容的先决条件。当学习更高级的系统内容时，翻阅一下此书的相应章节，同时编程实现其中的例子，一定会对书本上的理论具有更加感性的认识，真正做到经手的代码，从上层设计到底层实现都了然于胸，并能在脑中回放数据在网络-&gt;内存-&gt;缓存-&gt;CPU 的流向。</p>
<p>数据结构与算法基础</p>
<p>如今，很多人认为编程（特别是做 web 开发）的主要部分就是使用别人的代码，能够用清晰简明的方式表达自己的想法比掌握硬核的数学与算法技巧重要的多，数据结构排序函数二分搜索这不都内置了吗？工作中永远用不到，学算法有啥用啊？这种扛着实用主义大旗的「码农」思想当然不可取。没有扎实的理论背景，遭遇瓶颈是迟早的事。</p>
<p>数据结构和算法是配套的，入门阶段你应该掌握的主要内容应该是：这个问题用什么算法和数据结构能更快解决。这就要求你对常见的数据结构和算法了熟于心，你不一定要敲代码，用纸手写流程是更快的方式。对你不懂的数据结构和算法，你要去搜它主要拿来干嘛的，使用场景是什么。</p>
<p>供你参考的学习资源：</p>
<p>• 《算法导论》：有人说别把这本书当入门书，这本书本来就不是入门书嘛，虽说书名是 Introduction to Algorithms，这只不过是因为作者不想把这本书与其他书搞重名罢了。当然，也不是没办法拿此书入门，读第一遍的时候跳过习题和证明就行了嘛，如果还觉得心虚先看看这本《数据结构与算法分析》<br>
• Algorithms: Design and Analysis [Part 1] &amp; [Part 2]： Stanford 开的算法课，不限定语言，两个部分跟下来算法基础基本就有了；如果英文不过关：麻省理工学院：算法导论<br>
• 入门阶段还要注意培养使用常规算法解决小规模问题的能力，结合前文的SICP部分可以读读这几本书：《编程珠玑》，《程序设计实践 》<br>
编程语言基础</p>
<p>Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut. Additionally, learning many languages is far easier now, thanks to the wealth of freely available software on the Internet</p>
<ul>
<li>The Pragmatic Programmer</li>
</ul>
<p>此外还要知道，学习第 n 门编程语言的难度是第 (n-1) 门的一半，所以尽量去尝试不同的编程语言与编程范式，若你跟寻了前文的指引，你已经接触了：「干净」的脚本语言 Python, 传统的命令式语言 C, 以及浪漫的函数式语言 Scheme 三个好朋友。但仅仅是接触远远不够，你还需要不断继续加深与他们的友谊，并尝试结交新朋友，美而雅的 Ruby 小姑娘，Hindley-Milner 语言家族的掌中宝 Haskell 都是不错的选择。至于 C++ ，喜欢的话学学也无妨。</p>
<p>现实是残酷的，在软件工程领域仍旧充斥着一些狂热者，他们只掌握着一种编程语言，也只想掌握一种语言，他们认为自己掌握的这门语言是最好的，其他异端都是傻X。这种人也不是无药可救，有一种很简单的治疗方法：让他们写一个编译器。要想真正理解编程语言，你必须亲自实现一个。现在是入门阶段，不要求你去上一门编译器课程，但要求你能至少实现一个简单的解释器。</p>
<p>供你参考的学习资源：</p>
<p>• 《程序设计语言-实践之路》：CMU 编程语言原理的教材，程序语言入门书，现在就可以看，会极大扩展你的眼界，拉开你与普通人的差距。<br>
• Programming Languages：课堂上你能接触到极端 FP （函数式）的 SML，中性偏 FP 的 Racket，以及极端 OOP （面向对象）的 Ruby，并学会问题的 FP 分解 vs OOP 分解、ML 的模式匹配、Lisp 宏、不变性与可变性、解释器的实现原理等，让你在将来学习新语言时更加轻松并写出更好的程序。<br>
• Udacity CS262 Programming Language：热热身，教你写一个简单的浏览器——其实就是一个 JavaScript 和 HTML 的解释器，完成后的成品还是很有趣的；接下来，试着完成一个之前在SICP部分提到过的项目：用Python写一个 Scheme Interpreter<br>
其他</p>
<p>编程入门阶段比较容易忽视的几点：</p>
<p>1 学会提问：学习中肯定会遇到问题，应该学会正确的使用搜索引擎。当单靠检索无法解决问题时，去 Stack Overflow 或知乎提问，提问前读读这篇文章：能有效解决问题的提问方法。<br>
2 不要做一匹独狼：尝试在 CoCode 与他人交流想法。尝试搭建一个像这样简单的个人网站。试着在博客上记录自己的想法。订阅自己喜欢的编程类博客，推荐几个供你参考：Joel on Software, Peter Norvig, Coding Horror<br>
3 学好英语：英语是你获取高质量学习资源的主要工具，但在入门阶段，所看的那些翻译书信息损耗也没那么严重，以你自己情况权衡吧。<br>
小结</p>
<p>以上的内容你不应该感到惧怕，编程的入门不是几个星期就能完成的小项目。期间你还会遇到无数的困难，当你碰壁时试着尝试「费曼」技巧：将难点分而化之，切成小知识块，再逐个对付，之后通过向别人清楚地解说来检验自己是否真的理解。当然，依旧会有你解决不了的问题，这时候不要强迫自己——很多时候当你之后回过头来再看这个问题时，一切豁然开朗。</p>
<p>此外不要局限于上文提到的那些材料，还有一些值得在入门阶段以及将来的提升阶段反复阅读的书籍。这里不得不提到在 Stack Overflow 上票选得出的程序员必读书单中，排在前两位的两本书：</p>
<p>Code Complete：不管是对于经验丰富的程序员还是对于那些没有受过太多的正规训练的新手程序员，此书都能用来填补自己的知识缺陷。对于入门阶段的新手们，可以重点看看涉及变量名，测试，个人性格的章节。</p>
<p>The Pragmatic Programmer :有人称这本书为代码小全：从 DRY 到 KISS，从做人到做程序员均有涉及。</p>
<p>这本书的作者 Dave ，在书中开篇留了这样一段话：</p>
<p>You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allows you to choose good solutions in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstances and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.</p>
<p>这段话以及他创立的 The Pragmatic Bookshelf 一直以来都积极地影响着我，因此这篇指南我也尽量贯彻了这个思想，引导并希望你们成为一名真正的 Pragmatic Programmer 。</p>
<p>后记</p>
<p>如果你能设法完成以上的所有任务，恭喜你，你已经真正实现了编程入门。这意味着你在之后更深入的学习中，不会畏惧那些学习新语言的任务，不会畏惧那些「复杂」的 API，更不会畏惧学习具体的技术，甚至感觉很容易。当然，为了掌握这些东西你依旧需要大量的练习，腰还是会疼，走路还是会费劲，一口气也上不了5楼。但我能保证你会在思想上有巨大的转变，获得极大的自信，看老师同学和 CSDN 的眼光会变得非常微妙，虽然只是完成了编程入门，但已经成为了程序员精神世界的高富帅。不，我说错了，即使是高富帅也不会有强力精神力，他也会怀疑自己，觉得自己没钱就什么都不是了。但总之，你遵循指南好好看书，那就会体验「会当凌绝顶」的感觉。</p>
<p>欢迎实践过的同学现身说法。几位读者的实例：</p>
<p>• 非计算机专业，计算机如何入门？ - 浪无痕<br>
• 我只想成为一名合格的程序员<br>
• 知乎《编程入门指南v1.3》思维导图</p>
<p>附(zhèng)录(wén)</p>
<p>@萧井陌的编程类回答汇总</p>
<p>方向：</p>
<p>• 怎么成为一个优秀的程序员，而不是一个优秀的码农？<br>
优秀的程序员会告诉你打根基的重要性，会劝你在厚积薄发前要隐忍。</p>
<p>优秀的程序员应该善用包装...</p>
<p>• 计算机本科应届毕业生要有怎样的能力才算比较好的？<br>
对本科生的要求其实很简单，认真学过专业课就行。</p>
<p>所谓认真学过专业课的程度是：...</p>
<p>• 想进入微软，本科该如何努力？<br>
你可以找一个美国大学学他们的计算机课程，课程设置和教材都能查到，书都能买到。那几所学校的本科课程安排差异比较大，全学也不是不可以。做好这几点: ...</p>
<p>• 大四学生，想通过两到三年的积累去Google工作，请问应如何准备？<br>
我觉得你得先找到一个技术方向，树立一个以此技术方向为首要目标的原则，做好这个方面的事情，对这个方面的所有技术细节都务求深入了解。然后呢...</p>
<p>• 文科生如何转行当程序员？考研是最好选择吗？<br>
0. 找一本《计算机导论》类的书籍看看，了解一下行业大致情况，随便翻翻就好</p>
<ol>
<li>去维基百科翻一下历年图灵奖得奖情况，粗略了解一下行业历史...</li>
</ol>
<p>• 有哪些适合程序员读的人文书籍？<br>
程序员也是人, 程序员的整体素质在其他行业也是通用的.</p>
<p>so.... 这就产生了很多其他行业的书...</p>
<p>方法：</p>
<p>• 如何学习不感兴趣但自己也认为很重要的东西?<br>
• 兴趣广泛和保持专注是否矛盾？<br>
• 在学习编程的过程中如何权衡寻求方法工具和埋头苦干？<br>
• 新手关于如何看编程经典书的一些疑惑？<br>
• 计算机方面的经典书籍，不做或少做习题会对学习效果造成多大影响呢？<br>
• 有哪些老鸟程序员知道而新手不知道的小技巧？<br>
• 改bug是程序员的任务里比较低贱的工作内容吗？<br>
• 如何辨别一个程序员水平的高低？</p>
<p>细分：</p>
<p>• 如何去学习程序员的三大浪漫，编译原理，图形学，操作系统？<br>
• 数据库、操作系统、编译原理应该以怎样的的顺序学习？<br>
◦ 如何在六个月的时间内完成一个简单的操作系统，应该要学些什么？<br>
◦ 计算机系大四学生如何在六个月的时间内完成一个编译器？要学些什么？<br>
• 算法到底应该怎么学？<br>
• WEB 开发还有前途吗？<br>
• 嵌入式开发还有前途吗？<br>
• 已参加工作的程序员如何系统提升英语阅读能力？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python学习笔记(番外)] 深拷贝和浅复制]]></title>
        <id>https://wind-uncovered.github.io/post/python-xue-xi-bi-ji-fan-wai-shen-kao-bei-he-qian-fu-zhi/</id>
        <link href="https://wind-uncovered.github.io/post/python-xue-xi-bi-ji-fan-wai-shen-kao-bei-he-qian-fu-zhi/">
        </link>
        <updated>2020-04-02T17:26:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="创建一个列表">创建一个列表</h3>
<pre><code class="language-python">lst2 = ['001','2019-11-11',['三文鱼','电烤箱']]
</code></pre>
<p>这个列表的结构示意图如下:<br>
<img src="https://wind-uncovered.github.io/post-images/1585848472399.png" alt="" loading="lazy"></p>
<h3 id="引用取出">引用取出</h3>
<pre><code class="language-python">sku=lst2[2]
print(sku)
&gt;&gt;&gt;['三文鱼','电烤箱']
</code></pre>
<p>此时其结构如下:<br>
<img src="https://wind-uncovered.github.io/post-images/1585848482980.png" alt="" loading="lazy"></p>
<p>如果我们对sku进行操作，lst2中的内容也会发生改变</p>
<pre><code class="language-python">sku.append('烤鸭')
sku.insert(1,'牛腱子')

sku,lst2
&gt;&gt;&gt;['三文鱼','牛腱子','电烤箱','烤鸭']
&gt;&gt;&gt;['001', '2019-11-11', ['三文鱼', '牛腱子', '电烤箱', '烤鸭']]
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://wind-uncovered.github.io/post-images/1585848491914.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">item=sku.pop()
sku.remove('三文鱼')

sku
&gt;&gt;&gt; ['牛腱子','电烤箱']
lst2
&gt;&gt;&gt;['001', '2019-11-11', ['牛腱子', '电烤箱']]
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://wind-uncovered.github.io/post-images/1585848501360.png" alt="" loading="lazy"></figure>
<p>以上展示了引用取出的效果。</p>
<p>为了避免更改复制内容是同时操作原内容，有两种拷贝方式，分别是内置的copy方法和标准库copy模块中的deepcopy函数。copy被称为shallow copy(浅拷贝), deepcopy被称为深拷贝。其具体情况展示如下:</p>
<h3 id="浅拷贝">浅拷贝</h3>
<pre><code class="language-python">lst2 = ['001','2019-11-11',['三文鱼','电烤箱']]

sku_deep = lst2[2].copy()
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://wind-uncovered.github.io/post-images/1585848511224.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">sku_deep.pop()
&gt;&gt;&gt;sku_deep
&gt;&gt;&gt;['三文鱼']
&gt;&gt;&gt;lst2[2]
&gt;&gt;&gt;['三文鱼','电烤箱']
</code></pre>
<p>结构示意图表名，sku_deep和lst2的元素不在同一结构中，因此互相之间不会造成干扰。</p>
<p>但是copy被叫做浅拷贝是有原因的，见下:</p>
<pre><code class="language-python">a = [1, 2, [3, 4, 5]]
ac = a.copy()
ac[0] = 10
ac[2][1] = 40

&gt;&gt;&gt;a[0] == ac[0]
&gt;&gt;&gt;False#说明浅拷贝成功
&gt;&gt;&gt;a[2][1] == ac[2][1]
&gt;&gt;&gt;True#这里再次关联了
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://wind-uncovered.github.io/post-images/1585848517430.png" alt="" loading="lazy"></figure>
<p>通过结构示意图，我们可以看到ac[2]和a[2]其实是关联的，因为copy在复制的时候，由于a[2]是一个嵌套，结果复制的是id(a[2])</p>
<h3 id="深拷贝">深拷贝</h3>
<pre><code class="language-python">from copy import deepcopy

a = [1,2,[3,4,5]]
ac = deepcopy(a)
ac[0] = 10
ac[2][1] = 40
print(a[0] == ac[0])
&gt;&gt;&gt; False
print(a[2][1] == ac[2][1])
&gt;&gt;&gt; False
</code></pre>
<p>这一次复制的结果都是False，说明a和ac指向了不同的内存区域。</p>
<p>查询id:</p>
<pre><code class="language-python">id(ac[2])
&gt;&gt;&gt;140647444908744
id(a[2])
&gt;&gt;&gt;140647444907528
</code></pre>
<p>结构:</p>
<figure data-type="image" tabindex="5"><img src="https://wind-uncovered.github.io/post-images/1585848524713.png" alt="" loading="lazy"></figure>
<p>由此可以看出深拷贝的本质</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python学习笔记(3)]  list和tuple，以及其简单应用]]></title>
        <id>https://wind-uncovered.github.io/post/python-xue-xi-bi-ji-3-list-he-tupleyi-ji-qi-jian-dan-ying-yong/</id>
        <link href="https://wind-uncovered.github.io/post/python-xue-xi-bi-ji-3-list-he-tupleyi-ji-qi-jian-dan-ying-yong/">
        </link>
        <updated>2020-04-02T17:22:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="list">list</h3>
<ul>
<li>list 是可增删的可变容器，其内部元素的类型不要求一致，可以进行嵌套</li>
</ul>
<h4 id="基本操作">基本操作</h4>
<ul>
<li>创建列表</li>
</ul>
<pre><code class="language-python">empty = []
lst = [1,'xiaoming',29.5,'17312662388']
lst2 = ['001','2019-11-11',['三文鱼','电烤箱']]
</code></pre>
<p><img src="https://wind-uncovered.github.io/post-images/1585848365906.png" alt="" loading="lazy"><br>
<img src="https://wind-uncovered.github.io/post-images/1585848371179.png" alt="" loading="lazy"><br>
<img src="https://wind-uncovered.github.io/post-images/1585848375864.png" alt="" loading="lazy"></p>
<ul>
<li>通过内置函数进行管理</li>
</ul>
<pre><code class="language-python">empty = []
lst = [1,'xiaoming',29.5,'17312662388']
lst2 = ['001','2019-11-11',['三文鱼','电烤箱']]

len(empty) # 0
len(lst) # 4
len(lst2) # 3

sku= lst[2]#通过索引取出对象
sku.append('烤鸭')
sku.pop()#弹出一个元素，返回被弹出的元素
sku.remove(value)#删除指定元素，无返回

print(lst2)
&gt;&gt;&gt;['001', '2019-11-11', ['牛腱子', '电烤箱']]

#上面的输出表面sku被改动的同时lst2也被改动了
# 通过复制可以不改动
sku_deep=lst2[2].copy()

</code></pre>
<h4 id="深浅拷贝">深浅拷贝</h4>
<p>关于拷贝另开了一篇文章</p>
<h4 id="切片">切片</h4>
<pre><code class="language-python">a=list(range(1,20,3))

&gt;&gt;&gt; a
&gt;&gt;&gt; [1, 4, 7, 10, 13, 16, 19]
</code></pre>
<ul>
<li>使用 a[-1] 获取 a 的最后一个元素，返回 int 型，值为 19；</li>
<li>使用 a[:-1] 获取除最后一个元素的切片 [1, 4, 7, 10, 13, 16]；</li>
<li>使用 a[1:5] 生成索引为 [1,5)（不包括索引 5）的切片 [4, 7, 10, 13]；</li>
<li>使用 a[1:5:2] 生成索引 [1,5) 但步长为 2 的切片 [4,10]；</li>
<li>使用 a[::3] 生成索引 [0,len(a)) 步长为 3 的切片 [1,10,19]；</li>
<li>使用 a[::-3] 生成逆向索引 [len(a),0) 步长为 3 的切片 [19,10,1]</li>
</ul>
<p>使用列表的逆向切片，只需要一行代码</p>
<pre><code class="language-python">def reverse(lst):
    return lst[::-1]
</code></pre>
<pre><code class="language-python">ra=reverse(a)

&gt;&gt;&gt;ra
&gt;&gt;&gt;[19, 16, 13, 10, 7, 4, 1]
</code></pre>
<hr>
<h3 id="tuple">tuple</h3>
<h4 id="基本操作-2">基本操作</h4>
<p>元组是一种不可变对象，不能增加和删除元素</p>
<ul>
<li>创建元组</li>
</ul>
<pre><code class="language-python">a = () # 空元组对象
b = (1,'xiaoming',29.5,'17312662388')
c = ('001','2019-11-11',['三文鱼','电烤箱'])
</code></pre>
<p>在切片上，元组的性质和list一致，要注意的第一点是，单元素的元组创建必须加上逗号，否则会被视为对象本身</p>
<pre><code class="language-python">class Dog():
    def __init__(self,name,age):
        self.name=name
        self.age=age
        
meme=Dog('mimi',12)

lst=(meme)
lst2=(meme,)

&gt;&gt;&gt;type(lst)
&gt;&gt;&gt;&lt;class '__main__.Dog'&gt;
&gt;&gt;&gt;type(lst2)
&gt;&gt;&gt;&lt;class 'tuple'&gt;
</code></pre>
<ul>
<li>统计方法</li>
</ul>
<pre><code class="language-python">from numpy import random

a = random.randint(1,5,10) # 从 [1,5) 区间内随机选择 10 个数
at = tuple(a) # 转 tuple：(1, 4, 2, 1, 3, 3, 2, 3, 4, 2)
at.count(3) # 统计 3 出现次数，恰好也为 3 次
</code></pre>
<p>count这个方法对于list也是成立的</p>
<h4 id="可变对象和不可变对象的本质">可变对象和不可变对象的本质</h4>
<p>不可变对象的本质在于其长度在创建后就确定了，因此不能增加也不能删除。</p>
<p>在嵌套了列表的元组中，被嵌套列表不能被转发引用</p>
<pre><code class="language-python">test=(1,2,[3,4],5,6)

sku=test[2]
&gt;&gt;&gt;TypeError: 'tuple' object is not callable
</code></pre>
<p>但是其元素的元素可以被直接修改</p>
<pre><code class="language-python">test[2].append('boom')

test[2]
&gt;&gt;&gt;[3,4,'boom']
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python学习笔记(2)] python 四大数据类型总结]]></title>
        <id>https://wind-uncovered.github.io/post/python-xue-xi-bi-ji-2-python-si-da-shu-ju-lei-xing-zong-jie/</id>
        <link href="https://wind-uncovered.github.io/post/python-xue-xi-bi-ji-2-python-si-da-shu-ju-lei-xing-zong-jie/">
        </link>
        <updated>2020-04-02T17:19:34.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="数值型">数值型</h3>
<p>数值型是python中最基本的数据类型，一般有int,float和bool三种类型，这些类型都是单元素的。</p>
<blockquote>
<p>前缀加上０x可以创建十六进制整数</p>
<p>e可以通过科学计数法表示浮点数，如1.05e3=1050.0</p>
</blockquote>
<h3 id="容器型">容器型</h3>
<p>容器型是可容纳多个元素的对象，比如list, tumple, dict, set这四种类型。这些类型是python内置类型。</p>
<blockquote>
<p>字典是一种哈希表，通过查询值隐射另一个值</p>
</blockquote>
<p>###　字符串型</p>
<p>python3中所有字符串类型被同一判定为shr对象，不论变量引用的都是单个字母还是一串字符串。</p>
<p>关于字符串有5个高频用法。</p>
<pre><code class="language-python">#strip 去除字符串前后的多余空格
&gt;&gt;&gt; '  I love python\t\n  '.strip()
&gt;&gt;&gt; 'I love python'

#replace 替换字符串
&gt;&gt;&gt; 'i love python'.replace(' ','_')
&gt;&gt;&gt; 'i_love_python'

#join 合并字符串
&gt;&gt;&gt; '_'.join(['book','stour','count'])
&gt;&gt;&gt; 'book_store_count'

#title 首字母大写
&gt;&gt;&gt; 'abc alice'.title()
&gt;&gt;&gt; 'Abc Alice'

#find 返回匹配字符串的起始索引
&gt;&gt;&gt; 'i love python'.find('python')
&gt;&gt;&gt; 7
#p是第八个字符，所以索引位置是7，所有字符串一律被认为是列表，但列表不能被认为是字符串
</code></pre>
<h4 id="具体应用判断字符串str1是否由str2旋转获得">具体应用：判断字符串str1是否由str2旋转获得</h4>
<pre><code class="language-python">def is_rotation(s1: str, s2: str) -&gt; bool:
    if s1 is None or s2 is None:
        return False
    if len(s1) != len(s2):
        return False

    def is_substring(s1: str, s2: str) -&gt; bool:
        return s1 in s2
    return is_substring(s1, s2 + s2)
</code></pre>
<h4 id="具体应用简单正则表达式">具体应用：简单正则表达式</h4>
<p>python的re模块提供了正则表达式检查功能，以下案例实现了密码检查</p>
<ul>
<li>密码要求6到20位</li>
<li>只包含英文字母和数字</li>
</ul>
<pre><code class="language-python">import re

pat = re.compile(r'[\da-zA-Z]{6,20}')

print(pat.fullmatch('asd_211223sad'),
      		pat.fullmatch('qw12'),
			pat.fullmatch('adsfa12dqd12121def1fee'),
      		pat.fullmatch('n0password'))

&gt;&gt;&gt; None, None, None, &lt;_sre.SRE_Match object; span=(0, 10), match='n0password'&gt;
</code></pre>
<h3 id="自定义类">自定义类</h3>
<p>python中使用关键字class定制类，self表示类实例对象本身</p>
<pre><code class="language-python">class Dog(object):
    pass
# 所用的类都继承object类，使用__dir__可查看

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[python学习笔记(1)] python 两大特性和四种基本语法]]></title>
        <id>https://wind-uncovered.github.io/post/python-bi-ji-1-python-liang-da-te-xing-he-si-chong-ji-ben-yu-fa/</id>
        <link href="https://wind-uncovered.github.io/post/python-bi-ji-1-python-liang-da-te-xing-he-si-chong-ji-ben-yu-fa/">
        </link>
        <updated>2020-04-02T16:36:10.000Z</updated>
        <content type="html"><![CDATA[<p>什么是强类型语言？什么事类型检查？语言的动态静态又是什么？</p>
<hr>
<p>[TOC]</p>
<hr>
<h3 id="什么是动态语言">什么是动态语言</h3>
<blockquote>
<p>了解动态语言，或者是静态语言，需要了解类型检查</p>
</blockquote>
<p>类型检查是验证类型约束的过程，编译器或解释器在编译阶段或运行阶段进行类型检查。其具体过程就是，通过变量的类型，判断它们在表达式中是否合理，即有无语法错误。</p>
<blockquote>
<p>类型检查发生在程序运行阶段，则称为动态类型语言</p>
<p>类型检查发生在程序编译阶段，则称为静态类型语言</p>
</blockquote>
<p>由于类型检查发生在编译阶段时，引用的类型已经确定，之后再改动就会发生错误，因此有了动态静态之分。</p>
<h3 id="什么是强类型语言">什么是强类型语言</h3>
<blockquote>
<p>不同类型变量混合计算的，叫做强类型语言</p>
<p>不同类型变量能混合运算的，叫做弱类型语言</p>
</blockquote>
<p>在Ｃ++中，字母可以按照ASCII映射为数字，因此两者可以混合计算，C++因此是弱类型语言。</p>
<h3 id="四种基本语法">四种基本语法</h3>
<p>python的基本语法以变量命名原则、缩进原则、特殊关键字原则和特殊运算符原则进行分类。</p>
<h4 id="命名规则">命名规则</h4>
<ul>
<li>不允许以数字开头，允许英文，数字和下划线</li>
<li>区分大小写</li>
<li>以下划线开头的变量有特殊含义：_代表不能直接被访问，__代表为类的私有成员，不能被导入和其他类变量访问</li>
<li>__xx__是特殊方法</li>
<li>一般变量命名使用下划线分割单词，不使用大小写</li>
<li>类名采用驼峰命名法</li>
<li>函数名使用首字母小写的驼峰命名</li>
<li>类方法名使用小写，下划线分割单词</li>
<li>特殊变量全部大写</li>
</ul>
<h4 id="缩进原则">缩进原则</h4>
<blockquote>
<p>代码的缩进代表四个空格，表达了代码的逻辑层次</p>
</blockquote>
<h3 id="特殊关键字原则">特殊关键字原则</h3>
<h3 id="特殊运算符">特殊运算符</h3>
]]></content>
    </entry>
</feed>